 LCS最长公共子序列，就是任意取2个X,Y序列（也可以考虑为向量或字符串），将X,Y中两个序列中都相同的元素取出来构成一个新的序列，但是最长公共子序列不唯一，最长公共子序列长度是一定的，所以我们要先把问题简化，求出两个序列的最长公共子序列长度。
一个已知序列都有Xi=<x1,x2...,xi>(1≤i≤m)，且我们将每个序列的最后一个字符设为xm，同理Yj=<y1,y2...,yj>(1≤j≤n),最后一个字符设为yn，这2个序列将构成一个新的子序列Zk=<z1,z2…zk>。zk则为ZK序列的最后一个字符，Zk∈LCS（X,Y）。
一定要特别注意：Xi,Yj,Zk是表示整个序列,xm,yn,zk表示序列中的每个元素字符，ZK和zk都是未知的！！！！

若xm=yn（最后一个字符相同），我们用反证法证明：该字符必是X与Y的任一最长公共子序列Z（设长度为k）的最后一个字符，即有zk = xm = yn 且显然有Zk-1∈LCS(Xm-1 , Yn-1)即Z的前缀Zk-1是Xm-1与Yn-1的最长公共子序列。此时，问题化归成求Xm-1与Yn-1的LCS（LCS(X , Y)的长度等于LCS(Xm-1 , Yn-1)的长度加1）。
若xm≠yn，用反证法证明：要么Z∈LCS(Xm-1, Y)，要么Z∈LCS(X , Yn-1)。由于zk≠xm与zk≠yn其中至少有一个必成立，若zk≠xm则有Z∈LCS(Xm-1 , Y)，同理，若zk≠yn 则有Z∈LCS(X , Yn-1)。其实在这里之前我看到的时候也不是特别懂，后面思考了一下，可以这么理解，若xm≠yn两个序列的最后一个字符都不相等，那Zk序列的最后一个字符是如何得到的呢？那只有两种可能，要么zk≠xm，要么zk≠yn，如果zk≠xm就说明zk跟X序列的最后一个字符就没关系了，就要从X序列中Xm-1（为xm的前一个字符xm-1，因为xm跟zk没有关系，所以要从它前面一个字符找起）和Y序列的最后一个字符开始找起，所以就有了Z∈LCS(Xm-1 , Y)，同理这样的解释也可以用在Y序列中得出，若zk≠yn 则有Z∈LCS(X , Yn-1)。
此时，问题化归成求Xm-1与Y的LCS及X与Yn-1的LCS。LCS(X , Y)的长度为：max{LCS(Xm-1 , Y)的长度, LCS(X , Yn-1)的长度}（就是求最大值，只要求出两个长度的最大值就是LCS的长度）。
这样就可以由此得出下面的推导：

 

设一个C[i,j] 记录序列Xi和Yj的最长公共子序列的长度，当i=0或j=0时，空序列是Xi和Yj的最长公共子序列，故c[i,j]=0。如果xi=yj那么就可以得出c[i,j]=c[i-1,j-1]+1。
部分代码：
            b = new string[X.Length, Y.Length];
            c = new int[X.Length + 1, Y.Length + 1];
            for (int i = 0; i <= X.Length; i++)
            {
                c[i, 0] = 0;//j=0,c[i,j]=0;表示最长公共子序列的长度为0
            }
            for (int j = 0; j <= Y.Length; j++)
            {
                c[0, j] = 0;//i=0,c[i,j]=0;表示最长公共子序列的长度为0
            }
            for (int i = 0; i < X.Length; i++)
            {
                for (int j = 0; j < Y.Length; j++)
                {
                    if (X[i] == Y[j])
                    {
                        c[i + 1, j + 1] = c[i, j] + 1;
                        b[i, j] = "left_up";//lu表示左上↖
                    }
                    else if (c[i, j + 1] >= c[i + 1, j])
                    {
                        c[i + 1, j + 1] = c[i, j + 1];
                        b[i, j] = "up";//up表示↑
                    }
                    else
                    {
                        c[i + 1, j + 1] = c[i + 1, j];
                        b[i, j] = "left"; //left表示←
                    }
                }
            }